use std::{collections::HashSet, hash::Hash, str::FromStr};

use clap::Parser;
use ruma::{
    api::{
        client::{device::Device, sync::sync_events::v3::RoomSummary},
        Direction,
    },
    events::room::{
        history_visibility::HistoryVisibility, join_rules::JoinRule,
    },
    room::RoomType,
    serde::Raw,
    OwnedEventId, OwnedMxcUri, OwnedRoomAliasId, OwnedRoomId,
    OwnedRoomOrAliasId, OwnedServerName, OwnedUserId, RoomVersionId,
};
use serde::Deserialize;

use crate::Result;

#[derive(Clone, Debug)]
pub(crate) struct QuerySet<T>(HashSet<T>);

impl<T> FromStr for QuerySet<T>
where
    T: Eq + Hash + for<'de> Deserialize<'de>,
{
    type Err = serde_json::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let split: Result<_, _> =
            s.split(',').map(str::trim).map(serde_json::from_str).collect();

        split.map(Self)
    }
}

#[derive(Clone, Debug, clap::Args)]
pub(crate) struct Query {
    query: QuerySet<String>,
    offset: usize,
    limit: usize,
    #[arg(value_parser = clap::value_parser!(String))]
    direction: Direction,
}

#[derive(Debug, Parser)]
#[command(name = "@grapevine:server.name:", version = env!("CARGO_PKG_VERSION"))]
pub(crate) enum Command {
    #[command(subcommand)]
    /// Commands for managing the server
    Server(Server),
    #[command(subcommand)]
    /// Commands for managing rooms
    Rooms(Room),
    #[command(subcommand)]
    /// Commands for managing local users
    Users(User),
    #[command(subcommand)]
    /// Commands for managing appservices
    Appservices(Appservice),
}

#[derive(Debug, clap::Subcommand)]
pub(crate) enum Server {
    /// Show configuration values
    Config(Query),

    /// Show configuration values
    ClearCache,

    /// Print database memory usage statistics
    MemoryUsage,
}

#[derive(Debug, clap::Subcommand)]
pub(crate) enum Room {
    List {
        servers: QuerySet<OwnedServerName>,
        ordering: RoomOrdering,

        #[command(flatten)]
        query: Query,
    },

    Update(Raw<RoomDetails>),
}

#[derive(Debug, clap::Subcommand)]
pub(crate) enum Appservice {
    /// List all the currently registered appservices
    List {
        #[command(flatten)]
        query: Query,
    },

    /// Register an appservice using its registration YAML
    ///
    /// This command needs a YAML generated by an appservice (such as a
    /// bridge), which must be provided in a Markdown code-block below the
    /// command.
    ///
    /// Registering a new bridge using the ID of an existing bridge will
    /// replace the old one.
    ///
    /// [commandbody]()
    /// # ```
    /// # yaml content here
    /// # ```
    // Allowed because the doc comment gets parsed by our code later
    #[allow(clippy::doc_markdown)]
    Register {
        // body: serde_yaml::Mapping,
    },

    /// Unregister an appservice using its ID
    ///
    /// You can find the ID using the `list-appservices` command.
    Unregister {
        /// The appservice to unregister
        appservices: QuerySet<String>,
    },
}

#[derive(Debug, clap::Subcommand)]
pub(crate) enum User {
    /// List users in the database
    List {
        servers: QuerySet<OwnedServerName>,
        rooms: QuerySet<OwnedRoomOrAliasId>,
        ordering: RoomOrdering,

        #[command(flatten)]
        query: Query,
    },

    Update(Raw<UserDetails>),

    /// Deactivate or delete a user
    ///
    /// User will not be removed from all rooms by default.
    /// Use --leave-rooms to force the user to leave all rooms
    Delete {
        users: HashSet<OwnedUserId>,
        /// Remove users from their joined rooms
        leave_rooms: bool,
        /// Remove users from their joined rooms
        purge: bool,
        /// Also deactivate admin accounts
        force: bool,
    },
}

#[derive(Debug, clap::Subcommand)]
pub(crate) enum Event {
    /// Get the auth_chain of a PDU
    AuthChain {
        /// An event ID (the $ character followed by the base64 reference hash)
        /// An event ID (a $ followed by the base64 reference hash)
        events: QuerySet<OwnedEventId>,
    },
}

#[derive(Debug, clap::Subcommand)]
pub(crate) enum Json {
    // /// List all rooms we are currently handling an incoming pdu from
    // List,
    #[command(verbatim_doc_comment)]
    /// Verify json signatures
    /// [commandbody]
    /// # ```
    /// # json here
    /// # ```
    Sign,

    #[command(verbatim_doc_comment)]
    /// Verify json signatures
    /// [commandbody]
    /// # ```
    /// # json here
    /// # ```
    Verify,
}

#[derive(Clone, Debug, clap::Subcommand)]
pub(crate) enum RoomOrdering {
    Alias,
    Timestamp,
    Members,
}

#[derive(Clone, Debug)]
pub(crate) struct RoomDetails {
    room: OwnedRoomId,
    version: RoomVersionId,
    creator: OwnedUserId,

    kind: RoomType,
    join_rule: JoinRule,
    history_visibility: HistoryVisibility,

    alias: Option<OwnedRoomAliasId>,
    avatar_url: Option<OwnedMxcUri>,
    summary: Option<RoomSummary>,

    federated: bool,
    published: bool,
}

#[derive(Clone, Debug, clap::Subcommand)]
pub(crate) enum UserOrdering {
    Displayname,
    Timestamp,
    Messages,
}

#[derive(Clone, Debug)]
pub(crate) struct UserDetails {
    user: OwnedUserId,
    password: Option<String>,

    updated: u64,
    created: u64,

    displayname: Option<String>,
    avatar_url: Option<OwnedMxcUri>,
    devices: HashSet<Device>,

    deactivated: bool,
    admin: bool,
}
